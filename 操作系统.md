<!-- TOC -->

- [内存](#内存)
  - [操作系统是如何管理虚拟地址与物理地址之间的关系？](#操作系统是如何管理虚拟地址与物理地址之间的关系)
    - [内存分段](#内存分段)
      - [分段机制下，虚拟地址和物理地址是如何映射的](#分段机制下虚拟地址和物理地址是如何映射的)
      - [分段的不足之处](#分段的不足之处)
    - [内存分页](#内存分页)
      - [分页是怎么阶段分段的内存碎片、内存交换效率低的问题？](#分页是怎么阶段分段的内存碎片内存交换效率低的问题)
      - [分页机制下，虚拟地址和物理地址是如何映射的？](#分页机制下虚拟地址和物理地址是如何映射的)
      - [多级页表](#多级页表)
    - [段页式内存管理](#段页式内存管理)
- [进程和线程](#进程和线程)
  - [进程和线程的区别](#进程和线程的区别)
    - [同一进程中的线程可以共享哪些数据？](#同一进程中的线程可以共享哪些数据)
    - [线程独占哪些资源？](#线程独占哪些资源)
  - [进程间通信有哪些方式？](#进程间通信有哪些方式)
  - [进程同步问题](#进程同步问题)
    - [临界区的概念？](#临界区的概念)
    - [同步与互斥的概念](#同步与互斥的概念)
    - [并发、并行、异步的区别？](#并发并行异步的区别)
  - [什么是僵尸进程？](#什么是僵尸进程)
    - [僵尸进程的危害](#僵尸进程的危害)
  - [什么是孤儿进程？](#什么是孤儿进程)
  - [什么是协程？](#什么是协程)
    - [线程和协程的区别？](#线程和协程的区别)
  - [什么是用户态和内核态？](#什么是用户态和内核态)
    - [为什么要分用户态和内核态？](#为什么要分用户态和内核态)
    - [如何从用户态切换到内核态](#如何从用户态切换到内核态)
- [死锁](#死锁)
  - [什么是死锁？](#什么是死锁)
  - [死锁产生的必要条件](#死锁产生的必要条件)
  - [死锁有哪些处理方法？](#死锁有哪些处理方法)
    - [鸵鸟策略](#鸵鸟策略)
    - [死锁预防](#死锁预防)
    - [死锁避免](#死锁避免)
      - [银行家算法](#银行家算法)
    - [死锁解除](#死锁解除)
- [中断](#中断)
  - [什么是中断](#什么是中断)

<!-- /TOC -->

# 内存
## 操作系统是如何管理虚拟地址与物理地址之间的关系？
1. 内存分段
2. 内存分页

### 内存分段
#### 分段机制下，虚拟地址和物理地址是如何映射的
分段机制下的虚拟地址由两部分组成，段选择因子和段内偏移量
* 段选择因子保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等
* 虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址
#### 分段的不足之处
1. 内存碎片，会使用swap进行内存交换
2. 内存交换的效率低

### 内存分页
分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小，这样一个连续并且尺寸固定的内存空间，我们叫页。
> 在Linux下，每一页的大小为4KB
#### 分页是怎么阶段分段的内存碎片、内存交换效率低的问题？
* 内存空间是预先划分好的，释放的内存都是以页为但为释放的，因此不会产生无法给进程使用的小内存
* 内存空间不够时操作系统会把其他正在运行的进程中的"最近没被使用"的内存页面给释放掉。所以一次性写入磁盘的也只有少数的一个页或几个页，内存交换的效率就相对较高
#### 分页机制下，虚拟地址和物理地址是如何映射的？
在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址
1. 把虚拟内存地址，切分为页号和偏移量
2. 根据页号，从页表里面查询对应的物理页号
3. 物理页号加上前面的偏移量，得到物理内存地址
#### 多级页表
32位操作系统采用二级页表，64位操作系统采用四级页表。除第一级之外，可按需加载页表以节省空间

### 段页式内存管理
将内存分段和内存分页组合起来在同一个系统中使用


# 进程和线程
## 进程和线程的区别
1. 进程是操作系统进行资源分配和调度的基本单位；线程是CPU调度和分派的基本单位
2. 线程依赖进程而存在，一个进程至少有一个线程
3. 进程有自己的独立地址空间，线程共享所属进程的地址空间地址
4. 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器、一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、CPU等
5. 在进程切换时，涉及到整个当前进程CPU环境的保存、环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需要保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销远大于线程切换的开销
6. 线程之间的通信更方便，统一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行
7. 多线程程序只要有一个线程崩溃，整个程序就崩溃了；但多进程程序中一个进程崩溃并不会对其他进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮

### 同一进程中的线程可以共享哪些数据？
<details>
<summary>同一进程中的线程可以共享哪些数据？</summary>

1. 进程代码段
2. 进程的公有数据(全局变量、静态变量...)
3. 进程打开的文件描述符
4. 进程的当前目录
5. 信号处理器/信号处理函数：对收到的信号的处理方式
6. 进程ID与进程组ID
</details>

### 线程独占哪些资源？
<details>
<summary>线程独占哪些资源？</summary>

1. 线程ID
2. 一组寄存器的值
3. 线程自身的栈(堆是共享的)
4. 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其他线程修改
5. 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）
</details>

## 进程间通信有哪些方式？
参考文章如下：<br>
[【操作系统】进程间的通信方式](https://imageslr.com/2020/02/26/ipc.html)<br>
[进程间通信IPC (InterProcess Communication)](https://www.jianshu.com/p/c1015f5ffa74)

## 进程同步问题
### 临界区的概念？
<details>
<summary>临界区的概念</summary>
各个进程中对临界资源（互斥资源/共享变量，一次只能给一个进程使用）进行操作的程序片段
</details>

### 同步与互斥的概念
<details>
<summary>同步与互斥的概念</summary>
同步：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态；<br>
互斥：多个进程在同一时刻只有一个进程能进入临界区
</details>

### 并发、并行、异步的区别？
<details>
<summary>并发、并行、异步的区别？</summary>
并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在cpu上运行，宏观上的并发是通过不断的切换实现的；<br>
并行：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的;<br>
异步：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事情
</details>

## 什么是僵尸进程？
一个子进程结束后，它的父进程并没有等待它(调用wait或者waitpid)，那么这个子进程将成为一个僵尸进程。<br>
僵尸进程是一个已经死亡的进程，但是没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态一级资源利用信息(cpu时间、内存使用量等等)供父进程收集，除此之外，僵尸进程不再占用任何内存空间。这个僵尸进程可能会一直留在系统中知道系统重启。

### 僵尸进程的危害
<details>
<summary>僵尸进程的危害</summary>

1. 占用进程号，系统所能使用的进程号是有限的
2. 占用内存
</details>

## 什么是孤儿进程？
一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init(进程ID为1)接管，当这些孤儿进程结束时由Init完成状态收集

## 什么是协程？
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁访问全局变量，所以上下文的切换非常快

### 线程和协程的区别？
<details>
<summary>线程和协程的区别</summary>

1. 一个线程可以拥有多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核cpu
2. 线程进程都是同步机制，而协程则是异步
3. 协程能保留上一次调用时的状态，每次协程重入时，就相当于进入上一次调用的状态
</details>

## 什么是用户态和内核态？
为了限制不同程序的访问能力，防止一些程序访问其他程序的内存数据，CPU划分了用户态和内核态两个权限等级。
* 用户态只能受限的访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其他程序获取
* 内核态可以访问内存所有数据以及外围设备，也可以进行程序切换
所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或键盘读取数据，这时就需要进程系统调用，使用陷阱指令，CPU切换到内核态，执行相应的服务，再切换到用户态并返回系统调用的结果。

### 为什么要分用户态和内核态？
<details>
<summary>为什么要分用户态和内核态？</summary>

* 安全性：防止用户程序恶意或者不小心破坏系统、内存、硬件资源
* 封装性：用户程序不需要实现更加底层的代码
* 利用调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便
</details>

### 如何从用户态切换到内核态
<details>
<summary>如何从用户态切换到内核态</summary>

* 系统调用：比如读取命令行输入。本质上还是通过中断实现的
* 用户程序发生异常时：比如缺页异常
* 外围设备的中断：外围设备完成用户请求操作后，会想CPU发出中断信号，这时CPU会转去处理对应的中断处理程序
</details>

# 死锁
## 什么是死锁？
在两个或者多个并发进程中，每个进程持有某种资源而又等待其他进程释放它们现在保持着的资源，在为改变这种状态之前不能向前推进，称这一组进程产生了死锁

## 死锁产生的必要条件
* **互斥**：一个资源只能被一个进程占用
* **占有并等待**：一个进程至少占有一个资源，并在等待另一个被其他进程占用的资源
* **非抢占**：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放
* **循环等待**：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中每个进程都在等待下一个进程所占有的资源

## 死锁有哪些处理方法？
### 鸵鸟策略
<details>
<summary>鸵鸟策略</summary>
直接忽略死锁，因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大的影响，或发生死锁的概率很低，可以采用鸵鸟策略。
</details>

### 死锁预防
>基本思想是破坏形成死锁的四个必要条件
<details>
<summary>死锁预防</summary>

* 破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本省并不具备这种属性，因此这种方案实用性有限；
* 破坏占有并等待条件
  * 施行资源预先分配策略(当一个进程开始运行之前，必须一次性向系统申请它所需的全部资源，否则不运行)
  * 只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）
  * 缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性
* 破坏非抢占条件：允许进程强行抢占被其他进程占有的资源。会降低系统的性能
* 破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源
</details>

### 死锁避免
<details>
<summary>死锁避免</summary>
动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进程资源的分配。所谓安全状态是指：即使所有进程突然请求需要的资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。
</details>

#### 银行家算法
待补充

### 死锁解除
>如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法
<details>
<summary>死锁解除</summary>

* 利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态
* 利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放自愿。要求系统保持进程的历史信息，设置还原点
* 利用杀死进程：强制杀死某些进程直到死锁接触为止，可以按照优先级进行
</details>

# 中断
## 什么是中断
中断是系统用来相应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的过程，然后调用内核中的中断处理程序来相应请求
* 硬中断: 中断处理程序上半部直接处理硬件请求，主要是负责耗时短的工作，特点是执行速度快
* 软中断：下半部是由内核触发，主要是负责上半部未完成的工作，通常是耗时比较长的事情，特点是执行慢
> linux系统里，可以通过查看/proc/softirqs的内容来知晓软中断的运行情况，/proc/interrupt来知晓硬中断的运行情况