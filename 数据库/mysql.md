# 索引
## 何为索引？有什么用？
索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有B树、B+树和Hash。

## 索引的优缺点
### 优点
* 使用索引可以加快数据的检索速度(减少检索的数据量)，是创建索引的主要原因
* 唯一索引可以保证数据库表中每一行数据的唯一性
### 缺点
* 创建索引和维护索引需要耗费许多时间，即增删改性能变慢
* 索引需要物理文件存储，也会耗费一定空间

## 索引的底层数据结构
### 哈希表
哈希表是键值对的集合，通过键可以快速去除对应的值(接近O(1))
#### mysql为什么不使用哈希表作为索引的数据结构呢？
1. Hash冲突问题
2. Hash索引不支持顺序和范围查询
### B树&B+树
B树即多路平衡查找树，B+树是B树的一种变体。目前大部分数据库系统及文件系统都采用B树或B+树作为索引结构

## MyISAM引擎和InnoDB引擎索引实现的区别
* MyISAM引擎中，B+树叶节点的data域存放的是数据记录的地址
    * 在索引检索的时候，首先按照B+树搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被成为**非聚集索引**
* InnoDB引擎中，其数据文件本身就是索引文件。根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引
  * 索引文件和数据文件是分离的，其表数据文件本身就是按照B+树组织的一个索引结构，树的叶节点的data域保存了完整的数据记录；这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为**聚集索引**
  * 而其余索引都为辅助索引，辅助索引的data域存储相应记录的主键的值

## 聚集索引和非聚集索引
### 聚集索引
即索引结构和数据一起存放的索引。主键索引属于聚集索引。
> 在mysql中InnoDB引擎的表的*.ibd*文件就包含了该表的索引和数据，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。
#### 优点
* 查询速度非常快，定位到索引的节点就相当于定位到了数据
#### 缺点
* 依赖于有序的数据
* 更新代价大，所以对于主键索引来说，主键一般都是不可被修改的

### 非聚集索引
即索引结构和数据分开存放的索引。辅助索引属于非聚集索引
> MyISAM引擎的表的*.MYI*文件包含了表的索引，该表的索引(B+树)的每个叶子非叶子节点存储索引，叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。
#### 优点
* 更新代价比聚集索引小
#### 缺点
* 也依赖有序的数据
* 可能会二次查询(回表)

## 覆盖索引
覆盖索引即需要查询的字段正好是索引的字段，那么直接根据所该索引就可以查到数据，无需回表查询

## 创建索引的注意事项
1. 选择合适的字段创建索引
   * 不为NULL的字段
   * 被频繁查询的字段
   * 被作为条件查询的字段
   * 频繁需要排序的字段
   * 被经常频繁用于链接的的字段
2. 被频繁更新的字段应该慎重建立索引(维护索引的成本不小)
3. 尽可能的考虑建立联合索引而不是单列索引
4. 避免冗余的索引
5. 考虑在字符串类型的字段上使用前缀索引代替普通索引

## 使用索引的一些建议
1. 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合键索引
2. 避免where自居中对字段施加函数，这会造成无法命中索引
3. 在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键
4. 删除长期未使用的索引，减少不必要的性能损耗
5. 在使用limit offset查询缓慢时可以借助索引来提高性能


# 事务
事务是逻辑上的一组操作，要么都执行，要么都不执行
## 事务的特性(ACID)
* 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用
* 一致性：执行事务前后，数据保持一致
* 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间的数据库是独立的
* 持久性：一个事务被提交之后，对数据库中的数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响

## 并发事务带来的问题
* **脏读**：当一个事务正在访问数据并且对数据进行修改时，而修改还没有提交到数据库中，这时另一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是"脏数据"，依据"脏数据"所做的操作可能是不正确的
* **丢失修改**：在一个事务读取数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。
*  **不可重复读**：在一个事务内多次读同一数据，另一个事务也访问了该数据并进行了修改，导致第一个事务两次读取的数据不一致
*  **幻读**：与不可重复读类型。在一个事务读取数据时另一个事务插入或删除了一些数据，随后的查询中，第一个事务发现与上一次查询的数据不一致就好像发生了幻觉一样
### 不可重复读和幻读的区别
不可重复读的重点是修改，幻读的重点在于新增或删除

## 事务的隔离级别
> InnoDB存储引擎的默认支持的隔离级别是REPEATABLE-READ(可重复读)
* **READ-UNCOMMITTED(读取未提交)**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、不可重复读
* **READ-COMMITTED(读取已提交)**：允许去读并发事务已提交的数据，可以阻止脏读，会导致幻读和不可重复读
* **REPEATABLE-READ(可重复读)**：对同一个字段的多次读取结果是一致的，除非数据是被本身事务所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生
* **SERIALIZABLE(可串行化)**：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，可以防止脏读、不可重复读和幻读。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :-: | :-: | :-: | :-: |
| READ-UNCOMMITTED | ✅ | ✅ | ✅ |
| READ-COMMITTED | ❌ | ✅ | ✅ |
| REPEATABLE-READ | ❌ | ❌ | ✅ |
| SERIALIZABLE | ❌ | ❌ | ❌ |


# 日志
MySQL日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中比较重要的属二进制日志*binlog*(归档日志)和事务日志*redo log*(重做日志)、*undo log*(回滚日志)

## redo log
*redo log*(重做日志)是InnoDB存储引擎独有的，它让MySQL拥有了奔溃恢复能力
> 比如MySQL实例挂了或宕机了，重启时，InnoDB存储引擎会使用redo log恢复数据，保证数据的持久性和完整性

mysql中数据是以页为单位，查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，放到Buffer Pool中，后续的查询都是先从Buffer pool中找，没有命中再去硬盘加载，减少硬盘IO开销提升性能。更新数据的时候，发现Buffer Pool里存在要更新的数据，就直接在Buffer Pool里更新，然后会把"在某个数据页上做了什么修改"记录到重做日志缓存(redo log buffer)里，接着刷盘到redo log文件里。

