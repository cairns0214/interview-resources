<!-- TOC -->

- [索引](#索引)
  - [何为索引？有什么用？](#何为索引有什么用)
  - [索引的优缺点](#索引的优缺点)
    - [优点](#优点)
    - [缺点](#缺点)
  - [索引的底层数据结构](#索引的底层数据结构)
    - [哈希表](#哈希表)
      - [mysql为什么不使用哈希表作为索引的数据结构呢？](#mysql为什么不使用哈希表作为索引的数据结构呢)
    - [B树&B+树](#b树b树)
  - [MyISAM引擎和InnoDB引擎索引实现的区别](#myisam引擎和innodb引擎索引实现的区别)
  - [聚集索引和非聚集索引](#聚集索引和非聚集索引)
    - [聚集索引](#聚集索引)
      - [优点](#优点-1)
      - [缺点](#缺点-1)
    - [非聚集索引](#非聚集索引)
      - [优点](#优点-2)
      - [缺点](#缺点-2)
  - [覆盖索引](#覆盖索引)
  - [创建索引的注意事项](#创建索引的注意事项)
  - [使用索引的一些建议](#使用索引的一些建议)
- [事务](#事务)
  - [事务的特性(ACID)](#事务的特性acid)
  - [并发事务带来的问题](#并发事务带来的问题)
    - [不可重复读和幻读的区别](#不可重复读和幻读的区别)
  - [事务的隔离级别](#事务的隔离级别)
- [日志](#日志)
  - [redo log](#redo-log)
    - [刷盘时机](#刷盘时机)
      - [为什么一个没有提交事务的redo log记录也可能会刷盘](#为什么一个没有提交事务的redo-log记录也可能会刷盘)
    - [redo日志文件组](#redo日志文件组)
  - [binlog](#binlog)
    - [记录格式](#记录格式)
    - [写入机制](#写入机制)
    - [binlog 和 redo log的区别](#binlog-和-redo-log的区别)
  - [undo log](#undo-log)

<!-- /TOC -->

# 索引
## 何为索引？有什么用？
索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有B树、B+树和Hash。

## 索引的优缺点
### 优点
* 使用索引可以加快数据的检索速度(减少检索的数据量)，是创建索引的主要原因
* 唯一索引可以保证数据库表中每一行数据的唯一性
### 缺点
* 创建索引和维护索引需要耗费许多时间，即增删改性能变慢
* 索引需要物理文件存储，也会耗费一定空间

## 索引的底层数据结构
### 哈希表
哈希表是键值对的集合，通过键可以快速去除对应的值(接近O(1))
#### mysql为什么不使用哈希表作为索引的数据结构呢？
1. Hash冲突问题
2. Hash索引不支持顺序和范围查询
### B树&B+树
B树即多路平衡查找树，B+树是B树的一种变体。目前大部分数据库系统及文件系统都采用B树或B+树作为索引结构

## MyISAM引擎和InnoDB引擎索引实现的区别
* MyISAM引擎中，B+树叶节点的data域存放的是数据记录的地址
    * 在索引检索的时候，首先按照B+树搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被成为**非聚集索引**
* InnoDB引擎中，其数据文件本身就是索引文件。根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引
  * 索引文件和数据文件是分离的，其表数据文件本身就是按照B+树组织的一个索引结构，树的叶节点的data域保存了完整的数据记录；这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为**聚集索引**
  * 而其余索引都为辅助索引，辅助索引的data域存储相应记录的主键的值

## 聚集索引和非聚集索引
### 聚集索引
即索引结构和数据一起存放的索引。主键索引属于聚集索引。
> 在mysql中InnoDB引擎的表的*.ibd*文件就包含了该表的索引和数据，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。
#### 优点
* 查询速度非常快，定位到索引的节点就相当于定位到了数据
#### 缺点
* 依赖于有序的数据
* 更新代价大，所以对于主键索引来说，主键一般都是不可被修改的

### 非聚集索引
即索引结构和数据分开存放的索引。辅助索引属于非聚集索引
> MyISAM引擎的表的*.MYI*文件包含了表的索引，该表的索引(B+树)的每个叶子非叶子节点存储索引，叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。
#### 优点
* 更新代价比聚集索引小
#### 缺点
* 也依赖有序的数据
* 可能会二次查询(回表)

## 覆盖索引
覆盖索引即需要查询的字段正好是索引的字段，那么直接根据所该索引就可以查到数据，无需回表查询

## 创建索引的注意事项
1. 选择合适的字段创建索引
   * 不为NULL的字段
   * 被频繁查询的字段
   * 被作为条件查询的字段
   * 频繁需要排序的字段
   * 被经常频繁用于链接的的字段
2. 被频繁更新的字段应该慎重建立索引(维护索引的成本不小)
3. 尽可能的考虑建立联合索引而不是单列索引
4. 避免冗余的索引
5. 考虑在字符串类型的字段上使用前缀索引代替普通索引

## 使用索引的一些建议
1. 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合键索引
2. 避免where自居中对字段施加函数，这会造成无法命中索引
3. 在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键
4. 删除长期未使用的索引，减少不必要的性能损耗
5. 在使用limit offset查询缓慢时可以借助索引来提高性能


# 事务
事务是逻辑上的一组操作，要么都执行，要么都不执行
## 事务的特性(ACID)
* 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用
* 一致性：执行事务前后，数据保持一致
* 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间的数据库是独立的
* 持久性：一个事务被提交之后，对数据库中的数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响

## 并发事务带来的问题
* **脏读**：当一个事务正在访问数据并且对数据进行修改时，而修改还没有提交到数据库中，这时另一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是"脏数据"，依据"脏数据"所做的操作可能是不正确的
* **丢失修改**：在一个事务读取数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。
*  **不可重复读**：在一个事务内多次读同一数据，另一个事务也访问了该数据并进行了修改，导致第一个事务两次读取的数据不一致
*  **幻读**：与不可重复读类型。在一个事务读取数据时另一个事务插入或删除了一些数据，随后的查询中，第一个事务发现与上一次查询的数据不一致就好像发生了幻觉一样
### 不可重复读和幻读的区别
不可重复读的重点是修改，幻读的重点在于新增或删除

## 事务的隔离级别
> InnoDB存储引擎的默认支持的隔离级别是REPEATABLE-READ(可重复读)
* **READ-UNCOMMITTED(读取未提交)**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、不可重复读
* **READ-COMMITTED(读取已提交)**：允许去读并发事务已提交的数据，可以阻止脏读，会导致幻读和不可重复读
* **REPEATABLE-READ(可重复读)**：对同一个字段的多次读取结果是一致的，除非数据是被本身事务所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生
* **SERIALIZABLE(可串行化)**：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，可以防止脏读、不可重复读和幻读。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :-: | :-: | :-: | :-: |
| READ-UNCOMMITTED | ✅ | ✅ | ✅ |
| READ-COMMITTED | ❌ | ✅ | ✅ |
| REPEATABLE-READ | ❌ | ❌ | ✅ |
| SERIALIZABLE | ❌ | ❌ | ❌ |


# 日志
MySQL日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中比较重要的属二进制日志*binlog*(归档日志)和事务日志*redo log*(重做日志)、*undo log*(回滚日志)

## redo log
*redo log*(重做日志)是InnoDB存储引擎独有的，它让MySQL拥有了奔溃恢复能力
> 比如MySQL实例挂了或宕机了，重启时，InnoDB存储引擎会使用redo log恢复数据，保证数据的持久性和完整性
>
>每条redo记录由"表空间号+数据页号+偏移量+修改数据长度+具体修改的数据"组成

mysql中数据是以页为单位，查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，放到Buffer Pool中，后续的查询都是先从Buffer pool中找，没有命中再去硬盘加载，减少硬盘IO开销提升性能。更新数据的时候，发现Buffer Pool里存在要更新的数据，就直接在Buffer Pool里更新，然后会把"在某个数据页上做了什么修改"记录到重做日志缓存(redo log buffer)里，接着刷盘到redo log文件里。
![redo log交互](https://cdn.jsdelivr.net/gh/cairns0214/picture@master/img20211218174241.png)

### 刷盘时机
InnoDB存储引擎为redo log的刷盘策略提供了innodb_flush_log_ar_trx_commit参数，它支持三种策略
* **0**：设置为0的时候，表示每次事务提交时不进行刷盘操作
  * 如果mysql挂了或宕机可能会有1s的数据丢失
* **1**：设置为1的时候，表示每次数据提交时都将进行刷盘操作(默认值)
  * 只要事务提交成功，redo log记录就一定在硬盘里，不会有任何数据丢失
* **2**：设置为2的时候，表示每次事务提交时都只把redo log buffer内容写入page cache
  * 只要事务提交成功，redo log buffer中的内容会写入到文件系统缓存(page cache)。mysql挂了不会有任何数据丢失，宕机可能会有1s数据的丢失

innodb_flush_log_at_trx_commit 参数默认为 1 ，也就是说当事务提交时会调用 fsync 对 redo log 进行刷盘。另外，InnoDB 存储引擎有一个后台线程，每隔1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。
![redo刷盘操作](https://cdn.jsdelivr.net/gh/cairns0214/picture@master/img20211218175235.png)

#### 为什么一个没有提交事务的redo log记录也可能会刷盘
事务执行过程redo log记录是会写入redo log buffer中，这些redo log记录会被后台线程刷盘。除了后台线程每秒1次的轮询操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。
![20211218175502](https://cdn.jsdelivr.net/gh/cairns0214/picture@master/img20211218175502.png)

### redo日志文件组
硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的redo日志文件大小都是一样的。它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写。在个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint
* write pos 是当前记录的位置，一边写一边后移
* checkpoint 是当前要擦除的位置，也是往后推移

每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。

## binlog
mysql的逻辑日志，记录内容是语句的原始逻辑，类似于"给ID=2这一行的c字段加1"，属于mysql server层，不管用什么存储引擎，只要发生了表数据更新，都会产生binlog
### 记录格式
* **statement**：记录的内容是sql语句原文
* **row**：除了sql语句还包含了具体的操作数据，需要通过mysqlbinlog工具解析
* **mixed**：判断这条数据是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式
### 写入机制
事务执行过程中，先把日志写入到binlog cache中，事务提交的时候，把binlog cache写到binlog文件中。一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一块内存作为binlog cache。可以通过binlog_cache_size参数控制单个线程binlog cache大小，如果存储内容超过了这个参数，就要暂存到存盘(swap)中

### binlog 和 redo log的区别
* redo log让innodb存储引擎拥有了奔溃恢复能力
* binlog保证了mysql集群架构的数据一致性
* redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入

## undo log
通过undo log实现异常回滚，来保证事务的原子性
